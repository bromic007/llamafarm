name: Release - Desktop App

on:
  release:
    types:
      - published
  workflow_dispatch:
    inputs:
      version:
        description: "Version to build (e.g., v0.0.1)"
        required: true
        default: "v0.0.1"

permissions:
  contents: write

env:
  NX_NO_CLOUD: true

jobs:
  build-designer:
    name: Build Designer UI
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"
          cache-dependency-path: designer/package-lock.json

      - name: Install Designer dependencies
        working-directory: designer
        run: npm ci --legacy-peer-deps || npm install --legacy-peer-deps

      - name: Build Designer
        working-directory: designer
        run: |
          npm run build
          # Verify build output
          if [ ! -f "dist/index.html" ]; then
            echo "Error: Designer build failed - dist/index.html not found" >&2
            exit 1
          fi
          echo "‚úÖ Designer built successfully"

      - name: Upload Designer build
        uses: actions/upload-artifact@v4
        with:
          name: designer-dist
          path: designer/dist/
          retention-days: 1

  build:
    name: Build ${{ matrix.platform }} (${{ matrix.arch }})
    needs: build-designer
    runs-on: ${{ matrix.os }}

    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: macos
            arch: universal
            os: macos-latest

          - platform: linux
            arch: amd64
            os: macos-latest

          - platform: windows
            arch: amd64
            os: windows-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get version (Unix)
        if: runner.os != 'Windows'
        id: version-unix
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="${{ github.event.release.tag_name }}"
          fi
          VERSION_NO_V="${VERSION#v}"

          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "version_no_v=${VERSION_NO_V}" >> $GITHUB_OUTPUT
          echo "Using version: ${VERSION} (no v: ${VERSION_NO_V})"

      - name: Get version (Windows)
        if: runner.os == 'Windows'
        id: version-windows
        shell: pwsh
        run: |
          if ("${{ github.event_name }}" -eq "workflow_dispatch") {
            $VERSION = "${{ github.event.inputs.version }}"
          } else {
            $VERSION = "${{ github.event.release.tag_name }}"
          }
          $VERSION_NO_V = $VERSION -replace '^v', ''

          echo "version=$VERSION" >> $env:GITHUB_OUTPUT
          echo "version_no_v=$VERSION_NO_V" >> $env:GITHUB_OUTPUT
          echo "Using version: $VERSION (no v: $VERSION_NO_V)"

      - name: Set version output
        id: version
        shell: bash
        run: |
          if [ "${{ runner.os }}" = "Windows" ]; then
            VERSION="${{ steps.version-windows.outputs.version }}"
            VERSION_NO_V="${{ steps.version-windows.outputs.version_no_v }}"
          else
            VERSION="${{ steps.version-unix.outputs.version }}"
            VERSION_NO_V="${{ steps.version-unix.outputs.version_no_v }}"
          fi

          # If version is empty, use last tag + branch name as fallback
          if [ -z "$VERSION" ] || [ -z "$VERSION_NO_V" ]; then
            echo "‚ö†Ô∏è  Version is empty, generating fallback version..."

            # Get last git tag, or use v0.0.0 if no tags exist
            LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")

            # Get current branch name, sanitize it for version string
            BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD | sed 's/[^a-zA-Z0-9._-]/-/g')

            # Construct fallback version
            VERSION="${LAST_TAG}-${BRANCH_NAME}"
            VERSION_NO_V="${VERSION#v}"

            echo "‚úÖ Using fallback version: ${VERSION} (no v: ${VERSION_NO_V})"
          fi

          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "version_no_v=${VERSION_NO_V}" >> $GITHUB_OUTPUT

      - name: Download Designer build
        uses: actions/download-artifact@v4
        with:
          name: designer-dist
          path: designer/dist/

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"
          cache-dependency-path: electron-app/package-lock.json

      - name: Install Electron app dependencies
        working-directory: electron-app
        run: npm ci || npm install

      - name: Update app version in package.json
        working-directory: electron-app
        shell: bash
        run: |
          # Update version in package.json using Node.js
          node -e "
            const fs = require('fs');
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            pkg.version = '${{ steps.version.outputs.version_no_v }}';
            fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');
          "
          echo "‚úÖ Updated app version to ${{ steps.version.outputs.version_no_v }}"

      - name: Setup Apple credentials for macOS
        if: matrix.platform == 'macos'
        run: |
          # Create temporary directory for credentials
          mkdir -p /tmp/certs

          # Write P8 API key to file (electron-builder expects a file path)
          # Try to decode from base64 first, if that fails, write as-is
          if echo "${{ secrets.APPLE_NOTARY_KEY }}" | base64 -d > /tmp/certs/AuthKey_${{ secrets.APPLE_NOTARY_KEY_ID }}.p8 2>/dev/null; then
            echo "‚úÖ P8 API key decoded from base64 and written to file"
          else
            # Not base64, write directly
            echo "${{ secrets.APPLE_NOTARY_KEY }}" > /tmp/certs/AuthKey_${{ secrets.APPLE_NOTARY_KEY_ID }}.p8
            echo "‚úÖ P8 API key written to file directly"
          fi

          # Verify the P8 file was created and has content
          if [ ! -s /tmp/certs/AuthKey_${{ secrets.APPLE_NOTARY_KEY_ID }}.p8 ]; then
            echo "‚ùå Failed to create P8 key file or file is empty"
            exit 1
          fi

          # Show file info (without showing content)
          ls -lh /tmp/certs/AuthKey_${{ secrets.APPLE_NOTARY_KEY_ID }}.p8
          echo "‚úÖ P8 API key file created successfully"

      - name: Install Azure Trusted Signing for Windows
        if: matrix.platform == 'windows'
        shell: pwsh
        run: |
          Write-Host "üì¶ Installing Azure Trusted Signing PowerShell module..."

          # Install the Trusted Signing module from PowerShell Gallery
          Install-Module -Name TrustedSigning -Force -Scope CurrentUser -Repository PSGallery -AllowClobber

          # Verify installation
          $module = Get-Module -ListAvailable -Name TrustedSigning
          if ($module) {
            Write-Host "‚úÖ Trusted Signing module installed successfully"
            Write-Host "   Version: $($module.Version)"
          } else {
            Write-Host "‚ùå Failed to install Trusted Signing module"
            exit 1
          }

          # Import the module
          Import-Module TrustedSigning

          # Verify the cmdlet is available
          $cmdlet = Get-Command Invoke-TrustedSigning -ErrorAction SilentlyContinue
          if ($cmdlet) {
            Write-Host "‚úÖ Invoke-TrustedSigning cmdlet is available"
          } else {
            Write-Host "‚ùå Invoke-TrustedSigning cmdlet not found"
            exit 1
          }

      - name: Build and Sign Electron app
        working-directory: electron-app
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # macOS signing - using same secrets as CLI signing
          CSC_LINK: ${{ matrix.platform == 'macos' && secrets.APPLE_CERT_DATA || '' }}
          CSC_KEY_PASSWORD: ${{ matrix.platform == 'macos' && secrets.APPLE_CERT_PASSWORD || '' }}
          # Pass P8 file path instead of content
          APPLE_API_KEY: ${{ matrix.platform == 'macos' && format('/tmp/certs/AuthKey_{0}.p8', secrets.APPLE_NOTARY_KEY_ID) || '' }}
          APPLE_API_KEY_ID: ${{ matrix.platform == 'macos' && secrets.APPLE_NOTARY_KEY_ID || '' }}
          APPLE_API_ISSUER: ${{ matrix.platform == 'macos' && secrets.APPLE_NOTARY_ISSUER || '' }}
          # Windows Azure Trusted Signing credentials
          AZURE_TENANT_ID: ${{ matrix.platform == 'windows' && secrets.AZURE_TENANT_ID || '' }}
          AZURE_CLIENT_ID: ${{ matrix.platform == 'windows' && secrets.AZURE_CLIENT_ID || '' }}
          AZURE_CLIENT_SECRET: ${{ matrix.platform == 'windows' && secrets.AZURE_CLIENT_SECRET || '' }}
          AZURE_SIGNING_ENDPOINT: ${{ matrix.platform == 'windows' && 'https://eus.codesigning.azure.net/' || '' }}
          AZURE_SIGNING_CERTIFICATE_PROFILE: ${{ matrix.platform == 'windows' && 'llamafarm-app' || '' }}
          AZURE_SIGNING_ACCOUNT_NAME: ${{ matrix.platform == 'windows' && 'LlamaFarm' || '' }}
        run: |
          if [[ "${{ matrix.platform }}" == "macos" ]]; then
            # Remove identity: null from package.json to enable signing
            node -e "
              const fs = require('fs');
              const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
              delete pkg.build.mac.identity;
              fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');
            "

            # Verify P8 file exists
            if [ ! -f "$APPLE_API_KEY" ]; then
              echo "‚ùå P8 API key file not found at: $APPLE_API_KEY"
              exit 1
            fi
            echo "‚úÖ Using P8 API key at: $APPLE_API_KEY"
          fi

          echo "Building and signing Electron app for ${{ matrix.platform }}-${{ matrix.arch }}..."
          npm run build
          npx electron-builder --${{ matrix.platform }} --${{ matrix.arch == 'amd64' && 'x64' || matrix.arch }}
          echo "‚úÖ Electron app built successfully"
        shell: bash

      - name: Generate checksums (Unix)
        if: runner.os != 'Windows'
        working-directory: electron-app
        run: |
          VERSION_NO_V="${{ steps.version.outputs.version_no_v }}"
          cd "release/${VERSION_NO_V}"

          # Generate SHA256 for all distributable files (using shasum on macOS/Linux)
          if [[ "${{ matrix.platform }}" == "macos" ]]; then
            for file in LlamaFarm-desktop-app-mac*.dmg LlamaFarm-desktop-app-mac*.zip; do
              if [ -f "$file" ]; then
                shasum -a 256 "$file" > "$file.sha256"
                echo "‚úÖ Generated checksum for $file"
              fi
            done
          elif [[ "${{ matrix.platform }}" == "linux" ]]; then
            for file in LlamaFarm-desktop-app-linux*.AppImage LlamaFarm-desktop-app-linux*.deb; do
              if [ -f "$file" ]; then
                shasum -a 256 "$file" > "$file.sha256"
                echo "‚úÖ Generated checksum for $file"
              fi
            done
          fi
        shell: bash

      - name: Generate checksums (Windows)
        if: runner.os == 'Windows'
        working-directory: electron-app
        shell: pwsh
        run: |
          $VERSION_NO_V = "${{ steps.version.outputs.version_no_v }}"
          cd "release/$VERSION_NO_V"

          # Generate SHA256 for all distributable files (using PowerShell on Windows)
          Get-ChildItem -Filter "LlamaFarm-desktop-app-windows*.exe" | ForEach-Object {
            $hash = Get-FileHash -Algorithm SHA256 -Path $_.FullName
            "$($hash.Hash.ToLower())  $($_.Name)" | Out-File -FilePath "$($_.Name).sha256" -Encoding ascii
            Write-Host "‚úÖ Generated checksum for $($_.Name)"
          }

      - name: List build artifacts (Unix)
        if: runner.os != 'Windows'
        working-directory: electron-app
        shell: bash
        run: |
          VERSION_NO_V="${{ steps.version.outputs.version_no_v }}"
          echo "Build artifacts in release/${VERSION_NO_V}:"
          ls -lh "release/${VERSION_NO_V}/" || echo "No artifacts found"

      - name: List build artifacts (Windows)
        if: runner.os == 'Windows'
        working-directory: electron-app
        shell: pwsh
        run: |
          $VERSION_NO_V = "${{ steps.version.outputs.version_no_v }}"
          Write-Host "Build artifacts in release/${VERSION_NO_V}:"
          Get-ChildItem -Path "release/$VERSION_NO_V" -ErrorAction SilentlyContinue | Format-Table -AutoSize
          if ($LASTEXITCODE -ne 0) { Write-Host "No artifacts found" }

      - name: Upload release assets
        if: github.event_name != 'pull_request' &&
          (
          startsWith(github.ref, 'refs/heads/main') ||
          startsWith(github.ref, 'refs/heads/release/') ||
          startsWith(github.ref, 'refs/tags/v')
          )
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.version }}
          files: |
            electron-app/release/${{ steps.version.outputs.version_no_v }}/LlamaFarm-desktop-app-windows*.exe
            electron-app/release/${{ steps.version.outputs.version_no_v }}/LlamaFarm-desktop-app-mac*.dmg
            electron-app/release/${{ steps.version.outputs.version_no_v }}/LlamaFarm-desktop-app-mac*.zip
            electron-app/release/${{ steps.version.outputs.version_no_v }}/LlamaFarm-desktop-app-linux*.deb
            electron-app/release/${{ steps.version.outputs.version_no_v }}/LlamaFarm-desktop-app-linux*.AppImage
            electron-app/release/${{ steps.version.outputs.version_no_v }}/*.sha256
          fail_on_unmatched_files: false
          append_body: false

  add-release-notes:
    name: Add Release Notes
    needs: build
    runs-on: ubuntu-latest

    steps:
      - name: Get version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="${{ github.event.release.tag_name }}"
          fi
          VERSION_NO_V="${VERSION#v}"

          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "version_no_v=${VERSION_NO_V}" >> $GITHUB_OUTPUT

      - name: Update release with installation notes
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.version }}
          append_body: true
          body: |

            ## Desktop App Downloads

            ### macOS
            Download for Apple Silicon (M1+) or Intel Macs:
            - **Apple Silicon (arm64)**: `LlamaFarm-desktop-app-mac-arm64.dmg` or `.zip`
            - **Intel (x64)**: `LlamaFarm-desktop-app-mac-x64.dmg` or `.zip`

            **Installation:**
            1. Download the DMG or ZIP file for your architecture
            2. Open the DMG and drag LlamaFarm to Applications (or extract the ZIP)
            3. Launch the app (it's signed and notarized, so it will open normally)
            4. The app will auto-install the CLI and start services

            ### Linux
            Download the appropriate package for your Linux distribution:
            - **AppImage** (Universal): `LlamaFarm-desktop-app-linux.AppImage`
            - **Debian/Ubuntu**: `LlamaFarm-desktop-app-linux.deb`

            **Installation:**
            ```bash
            # AppImage (works on all distributions)
            chmod +x LlamaFarm-desktop-app-linux.AppImage
            ./LlamaFarm-desktop-app-linux.AppImage

            # Debian/Ubuntu
            sudo dpkg -i LlamaFarm-desktop-app-linux.deb
            ```

            ### Windows
            Download the Windows installer:
            - **Windows Installer**: `LlamaFarm-desktop-app-windows.exe`

            **Installation:**
            1. Download the installer
            2. Run the installer (it will install to your user directory)
            3. Launch LlamaFarm from the Start Menu
            4. The app will auto-install the CLI and start services

            ---

            ### Auto-Updates
            Once installed, the app will automatically check for updates and prompt you to install them.

  test-installation:
    name: Test macOS App Installation
    needs: build
    runs-on: macos-latest

    steps:
      - name: Get version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="${{ github.event.release.tag_name }}"
          fi
          VERSION_NO_V="${VERSION#v}"

          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "version_no_v=${VERSION_NO_V}" >> $GITHUB_OUTPUT
          echo "Using version: ${VERSION} (no v: ${VERSION_NO_V})"

      - name: Wait for release assets
        run: |
          echo "Waiting 60 seconds for release assets to be available..."
          sleep 60

      - name: Download and verify DMG (arm64)
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          # Download the arm64 DMG (testing on Apple Silicon runner)
          DMG_URL="https://github.com/llama-farm/llamafarm/releases/download/${VERSION}/LlamaFarm-desktop-app-mac-arm64.dmg"
          echo "Downloading from: $DMG_URL"

          # Download with retries
          MAX_ATTEMPTS=3
          ATTEMPT=0
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "Attempt $ATTEMPT of $MAX_ATTEMPTS..."

            if curl -L -f -o LlamaFarm.dmg "$DMG_URL"; then
              echo "‚úÖ Download successful"
              break
            fi

            if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
              echo "‚ö†Ô∏è  Download failed, retrying in 10 seconds..."
              sleep 10
            else
              echo "‚ùå ERROR: Failed to download DMG after $MAX_ATTEMPTS attempts"
              echo "The release may not have been published correctly."
              exit 1
            fi
          done

          # Verify the DMG exists and has content
          if [ ! -f "LlamaFarm.dmg" ]; then
            echo "‚ùå ERROR: DMG file not found after download"
            exit 1
          fi

          FILE_SIZE=$(stat -f%z "LlamaFarm.dmg")
          echo "‚úÖ DMG downloaded successfully (${FILE_SIZE} bytes)"

          # Verify minimum file size (DMG should be at least 50MB)
          MIN_SIZE=$((50 * 1024 * 1024))
          if [ $FILE_SIZE -lt $MIN_SIZE ]; then
            echo "‚ùå ERROR: DMG file is too small (${FILE_SIZE} bytes < ${MIN_SIZE} bytes)"
            echo "The file may be corrupted or incomplete"
            exit 1
          fi

          # Mount the DMG to verify it's valid
          hdiutil attach LlamaFarm.dmg -mountpoint /Volumes/LlamaFarm || {
            echo "‚ùå ERROR: Failed to mount DMG"
            exit 1
          }

          # Check if the app exists
          if [ ! -d "/Volumes/LlamaFarm/LlamaFarm.app" ]; then
            echo "‚ùå ERROR: LlamaFarm.app not found in DMG"
            hdiutil detach /Volumes/LlamaFarm 2>/dev/null || true
            exit 1
          fi

          echo "‚úÖ LlamaFarm.app found in DMG"

          # Verify app bundle structure
          if [ ! -f "/Volumes/LlamaFarm/LlamaFarm.app/Contents/MacOS/LlamaFarm" ]; then
            echo "‚ùå ERROR: App binary not found in bundle"
            hdiutil detach /Volumes/LlamaFarm
            exit 1
          fi

          echo "‚úÖ App bundle structure is valid"

          # Verify binary architecture
          ARCHITECTURES=$(lipo -archs "/Volumes/LlamaFarm/LlamaFarm.app/Contents/MacOS/LlamaFarm")
          echo "Binary architectures: $ARCHITECTURES"

          if [[ ! "$ARCHITECTURES" =~ "arm64" ]]; then
            echo "‚ùå ERROR: arm64 architecture not found in binary"
            hdiutil detach /Volumes/LlamaFarm
            exit 1
          fi

          echo "‚úÖ Binary contains arm64 architecture"

          # Unmount
          hdiutil detach /Volumes/LlamaFarm
          echo "‚úÖ DMG verification complete - all checks passed"
