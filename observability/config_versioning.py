"""
Config versioning utilities for LlamaFarm.

Hash-based config snapshots with smart deduplication.
Minimal overhead (~0.11ms per request).
"""

import hashlib
import json
import os
import tempfile
from typing import Any


def hash_config(config: Any) -> str:
    """
    Generate deterministic hash of config (FAST: ~0.1ms).

    Uses SHA256 for collision resistance.
    Excludes dynamic fields (timestamps, etc).

    Args:
        config: LlamaFarmConfig pydantic object

    Returns:
        Short hash like "sha256_a1b2c3d4e5f6"

    Example:
        >>> config = LlamaFarmConfig(...)
        >>> hash_config(config)
        'sha256_a1b2c3d4e5f6'
    """
    # Serialize config deterministically
    # - Exclude None values
    # - Use mode='json' to properly serialize enums and complex types
    #
    # Note: The exclude set is defensive. LlamaFarmConfig doesn't currently have
    # dynamic timestamp fields, but we exclude them anyway to ensure hash stability
    # if such fields are added in the future.
    config_dict = config.model_dump(
        mode='json',
        exclude_none=True,
        exclude={"created_at", "updated_at", "last_modified"},
    )

    # Convert to JSON with sorted keys for determinism
    config_json = json.dumps(config_dict, sort_keys=True)

    # Fast SHA256 hash
    hash_digest = hashlib.sha256(config_json.encode("utf-8")).hexdigest()

    # Return short hash (16 chars = 64 bits, good enough for collision resistance)
    return f"sha256_{hash_digest[:16]}"


def save_config_snapshot(
    config: Any,
    config_hash: str,
    namespace: str,
    project: str,
) -> bool:
    """
    Save config snapshot ONLY if it doesn't already exist (deduplication).

    Docker-compatible: Uses LF_DATA_DIR env var for path resolution.

    Args:
        config: LlamaFarmConfig pydantic object
        config_hash: Hash generated by hash_config()
        namespace: Project namespace
        project: Project name

    Returns:
        True if new snapshot saved, False if already exists

    Example:
        >>> config = LlamaFarmConfig(...)
        >>> config_hash = hash_config(config)
        >>> is_new = save_config_snapshot(config, config_hash, "default", "my-project")
        >>> if is_new:
        ...     print("New config version saved")
        ... else:
        ...     print("Config already exists")
    """
    # Get project path with security validation (follows ProjectService pattern)
    from .path_utils import get_project_path, validate_file_path

    project_dir = get_project_path(namespace, project)
    configs_dir = os.path.join(project_dir, "configs")
    os.makedirs(configs_dir, exist_ok=True)

    config_file = os.path.join(configs_dir, f"{config_hash}.json")

    # Security: Validate the config file path stays within configs directory
    validate_file_path(config_file, configs_dir, "config")

    # Check if already exists (deduplication)
    if os.path.exists(config_file):
        return False  # Already saved, no overhead

    # Save new config snapshot
    # Use mode='json' to properly serialize enums and complex types
    config_dict = config.model_dump(mode='json', exclude_none=True)
    config_json = json.dumps(config_dict, indent=2)

    # Atomic write using tempfile + os.replace()
    with tempfile.NamedTemporaryFile(
        mode="w",
        delete=False,
        dir=configs_dir,
        suffix=".tmp",
    ) as tmp:
        tmp.write(config_json)
        tmp_path = tmp.name

    # Atomic move (POSIX systems)
    os.replace(tmp_path, config_file)

    return True  # New snapshot saved


def get_config_by_hash(
    config_hash: str,
    namespace: str,
    project: str,
) -> dict | None:
    """
    Retrieve config snapshot by hash.

    Docker-compatible: Uses LF_DATA_DIR env var for path resolution.

    Args:
        config_hash: Hash generated by hash_config()
        namespace: Project namespace
        project: Project name

    Returns:
        Config dict or None if not found

    Example:
        >>> config_dict = get_config_by_hash("sha256_a1b2c3d4e5f6", "default", "my-project")
        >>> if config_dict:
        ...     print(f"Found config: {config_dict['name']}")
        ... else:
        ...     print("Config not found")
    """
    # Get project path with security validation (follows ProjectService pattern)
    from .path_utils import get_project_path, validate_file_path

    project_dir = get_project_path(namespace, project)
    configs_dir = os.path.join(project_dir, "configs")
    config_file = os.path.join(configs_dir, f"{config_hash}.json")

    # Security: Validate the config file path stays within configs directory
    validate_file_path(config_file, configs_dir, "config")

    if not os.path.exists(config_file):
        return None

    try:
        with open(config_file) as f:
            return json.load(f)
    except (OSError, json.JSONDecodeError):
        # Handle corrupted or unreadable config files
        return None
